<html><head><title>全文文本(Fulltext)</title><meta http-equiv='Content-Type' content='text/html; charset=UTF-8'><style>div.fullText table {width: 100%;text-indent: 1px;} 
 div.fullText table td.header {font-weight: bold;text-align: center;font-family: '宋体';font-size: 16px;line-height:20px;color: #000000;padding: 5px;}div.fullText table td.content {padding: 1px;text-align: left;vertical-align: top;width: 100%;font-family: '宋体';font-size: 14px;line-height:20px;color: #000000;}</style></head><body><?xml version="1.0" encoding="UTF-8"?><div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:siposeas="java:com.neusoft.sipo.sipopublicsearch.search.app.view.detailUtils.xsltParser.XsltSeasParser" xmlns:str="http://example.com/namespace" xmlns:business="http://www.sipo.gov.cn/XMLSchema/business" xmlns:base="http://www.sipo.gov.cn/XMLSchema/base" xmlns:tbl="http://oasis-open.org/specs/soextblx" class="fullText"><table><tr><td id="claim_title" class="header">权利要求书</td></tr><tr><td class="content" id="claim_1">1.一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，包括：</td></tr><tr><td class="content" id="claim_2">生成密钥；</td></tr><tr><td class="content" id="claim_3">进行加密；</td></tr><tr><td class="content" id="claim_4">利用自持私有的私钥解密过程；</td></tr><tr><td class="content" id="claim_5">其中，加密和解密过程可以分别用两大通式来简单地总结：加密过程，c＝g^m*r^n modn^2；解密过程，m＝L(c^lambda mod n^2)*u mod n；u＝(L(g^lambda mod n^2))^(-1)modn；</td></tr><tr><td class="content" id="claim_6">加法同态的验证过程。</td></tr><tr><td class="content" id="claim_7">2.根据权利要求1所述的一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，密钥生成的具体过程是：</td></tr><tr><td class="content" id="claim_8">步骤2.1、随机选取两个比较大的素数p和q，这两个数要同时满足两个条件：第一，p和q必须是非常大的素数，所谓素数也叫作质数，是在大于1的整数中，只能被1和这个数本身整除的数；第二、需要p和q这两个质数的长度相同，换言之，就是要求p和q满足gcd(p*q,(p-1)*(q-1))＝1；其中函数gcd()的作用就是返回两个整数的最大公约数，所以p和q满足p*q和(p-1)*(q-1)互为质数；</td></tr><tr><td class="content" id="claim_9">步骤2.2、计算p*q，并且令n＝p*q，lambda＝lcm(p-1，q-1)；其中，函数lcm()是用来返回两个整数的最小公倍数，所以把p-1和q-1的最小公倍数赋值给lambda；</td></tr><tr><td class="content" id="claim_10">步骤2.3、令nsquare＝n^2，上面介绍到Zn＝{x|x属于Z，0&amp;lt;＝x&amp;lt;＝n}，那么随机选取一个数g，使得g属于Zn^2，g是0到n^2中任意一个整数，但是g必要符合以下的条件：gcd{L(g^lambda mod n^2),n}＝1，其中mod是求余运算，A mod B表示A除以B的余数；</td></tr><tr><td class="content" id="claim_11">步骤2.4、如果g满足这个条件，那么就可以令加密算法的公钥为(g，n)，私钥为lambda；如果g不满足以上条件，就输出“g is not good.Choose g again.”,继续在指定范围内选取g，直到满足条件，生成算法的公钥和私钥。</td></tr><tr><td class="content" id="claim_12">3.根据权利要求1所述的一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，加密生成的具体过程是：</td></tr><tr><td class="content" id="claim_13">首先输入一个正整数作为一个待加密的明文m，但是明文m是有范围的：0&amp;lt;m&amp;lt;n，即m是属于Zn；然后我们要随机选择一个整数r，r是一个随机整数明文，作用是来帮助加密明文m的，r属于Zn*，即0&amp;lt;r&amp;lt;n；有了公钥(g，n)和随机明文r就能对明文m进行加密，令密文c是明文m加密狗对应的密文，于是就有：c＝g^m*r^n mod n^2，通过这个通式就能把明文加密成密文，完成加密算法。</td></tr><tr><td class="content" id="claim_14">4.根据权利要求3所述的一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，解密的具体过程是：</td></tr><tr><td class="content" id="claim_15">步骤4.1、，定义一个BigInteger u，使得u＝(L(g^lambda mod n^2))^(-1)mod n.；</td></tr><tr><td class="content" id="claim_16">步骤4.1、利用u进行对密文c的解密，利用通式——明文m＝L(c^lambda mod n^2)*umod n；这部分算法的输入为密文c，返回的是明文m，其中L(x)是一个数学函数L(x)＝(x-1)/n。</td></tr><tr><td class="content" id="claim_17">5.根据权利要求4所述的一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，密文的具体过程是：</td></tr><tr><td class="content" id="claim_18">首先输入两个明文m1和m2，分别利用加密算法进行加密，得到两个密文em1和em2，使得他们两个密文相加，得到sum，然后利用解密算法给密文sum进行解密，然后比较解密后的明文和原来两个明文m1和m2的和有什么关系，如果两个相等，则此算法满足加法同态加密，否则，不满足。</td></tr><tr><td class="content" id="claim_19">6.根据权利要求5所述的一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，在生成密钥后，就只要通过加密和解密算法就能加密明文和解密密文，在密钥的生成过程中有一个难点，那就是公钥(g，n)中g的产生；g的选择虽然是随意的，但是它是有条件限制的，g要满足两大条件：</td></tr><tr><td class="content" id="claim_20">条件一，0&amp;lt;&amp;lt;g&amp;lt;n^2，其中&amp;lt;&amp;lt;表示远小于，表示g既要在0和n^2之间，还要远大于0；</td></tr><tr><td class="content" id="claim_21">条件二，gcd{L(g^lambda mod n^2),n}＝1；如果直接这样找是很难找到满足条件的g的，所以我们可以利用逆向思维来思考问题；首先，我们令X1＝L(g^lambda mod n^2)，于是就有gcd(X1，n)＝1，就是说我们可以先找一个X1，使得X1和n互为质数，最小公约数为1，并且X1是小于n的；于是X1＝L(g^lambda mod n^2)＝(g^lambda mod n^2-1)/n，即化简可得：g^lambda mod n^2＝n*X1+1；由于X1小于n，所以n*X1+1小于n^2；此时可以令X2为g^lambda除以n^2的商，于是，g^lambda＝n^2*X2+n*X1+1；其中X2&amp;lt;n，通过这个算式推算出一个小于n^2的整数g。</td></tr></table></div><div xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:siposeas="java:com.neusoft.sipo.sipopublicsearch.search.app.view.detailUtils.xsltParser.XsltSeasParser" xmlns:str="http://example.com/namespace" xmlns:business="http://www.sipo.gov.cn/XMLSchema/business" xmlns:base="http://www.sipo.gov.cn/XMLSchema/base" xmlns:tbl="http://oasis-open.org/specs/soextblx" class="fullText"><table style="table-layout:fixed"><tr><td id="description_title" class="header">
						说明书
					</td></tr><tr><td class="content" id="description_invention_title">一种云计算中实现隐私保护的轻量级同态加密方法</td></tr><tr><td class="content" id="description_1">技术领域：</td></tr><tr><td class="content" id="description_2">本发明涉及安全云存储和计算，特别涉及云计算环境中数据安全和隐私保护。</td></tr><tr><td class="content" id="description_3">背景技术</td></tr><tr><td class="content" id="description_4">传统的对称加密体制和非对称加密体制的工作原理，分别如图1、图2所示。</td></tr><tr><td class="content" id="description_5">云计算时代的到来,虽然给人们带来了很多的便利,但是也给人们带来了恐慌---泄密问题日显突出，而上述传统的加密技术无法满足云计算的要求。</td></tr><tr><td class="content" id="description_6">2009年，IBM公司的科学家提出了世界上第一个全同态加密算法，这个算法有非常大的意义：它的存在证明了以前研究者关于全同态加密算法的假设并不是荒诞的、天马行空的，并且证明了全同态加密算法在理论上的可行性。</td></tr><tr><td class="content" id="description_7">全同态加密允许对任意加密数据的运算,即可以将明文的任意运算对应于相应的密文数据的特定操作,这种同态性使得在不可信终端对加密数据进行可信计算成为了可能。</td></tr><tr><td class="content" id="description_8">至少在理论上，这项技术从根本上解决了将数据及其操作委托给第三方时的保密问题。基于全同态加密的这个优点,它可以用于各种云计算中的隐私保护。</td></tr><tr><td class="content" id="description_9">不过，同态加密是基于数学难题的计算复杂性理论的密码学技术，全同态加密技术的复杂性使得人们又一次从希望变成失望。由于它的计算复杂性，使得现任的计算机还无法使它得到很好地实现。</td></tr><tr><td class="content" id="description_10">因此，研究者的研究方向应该不光只有新的全同态加密算法的提出，还应该注力于全同态加密算法的优化研究，在保证其安全性和同态性的基础上，通过降低算法密钥的长度，来减少加密的计算轮数，降低算法的复杂性，从而实现全同态加密算法的优化。</td></tr><tr><td class="content" id="description_11">发明内容</td></tr><tr><td class="content" id="description_12">同态加密算法对加密的数据进行计算得到一个输出，将这一输出进行解密，解密的结果就与用同一方法计算未加密的明文得到的输出结果是一样的。在同态加密算法的分类上，我们规定：如果这种同态关系只满足加法运算或者只满足乘法运算，那么就称这种同态加密算法为加同态加密算法或者乘同态加密算法。如果一种加密算法同时满足加法和乘法运算，则称全同态加密算法。</td></tr><tr><td class="content" id="description_13">我们知道所谓全同态加密算法是满足所有操作同态性的加密算法，然而加密算法在应用时并不是都要求全操作同态的，比如数据库的加密算法就只要求满足SQL语句执行的同态性；检索的加密算法只要满足加法和顺序的同态性等等。所以，我们在研究全同态加密算法的同时，应该还要着手像Cryptdb算法这样实现部分操作的同态加密算法的研究。我们研究算法最终的目的当然是算法的应用，使它能给我们带来便利和益处，所以实现部分操作同态性的加密算法的研究对于同态加密算法的应用也有着很大的推进作用。</td></tr><tr><td class="content" id="description_14">对于云计算来说，如果应用的每一个同态加密算法的密钥都那么长，那么每个加密算法的加密轮数自然不会低，就大大的提高了云计算系统的工作量，这样的同态加密算法虽然能保证云计算数据储存和传输的安全性，但是也会使本来运行起来就复杂的云计算系统变得越来越复杂，那么就需要更多的计算机来构建云计算系统，于是就大大地增加了云计算系统的构建成本，就会使得公司的经济效益降低。这样的同态加密算法就无法使得云计算给我们带来的便利得到最大化，无法使得公司的利益最大化，自然就会影响市场的积极性，那么对加密算法轻量化的研究就会变得十分迫切。</td></tr><tr><td class="content" id="description_15">本发明旨在对同态加密算法轻量化，实现轻量化同态加密。在尽量不降低加密算法的安全性的前提下，可以让密钥的长度降低，使得算法的加密和解密过程的轮数更少，速率更快。</td></tr><tr><td class="content" id="description_16">本发明采用如下技术方案：</td></tr><tr><td class="content" id="description_17">一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，包括：</td></tr><tr><td class="content" id="description_18">生成密钥；</td></tr><tr><td class="content" id="description_19">进行加密；</td></tr><tr><td class="content" id="description_20">利用自持私有的私钥解密过程；</td></tr><tr><td class="content" id="description_21">其中，加密和解密过程可以分别用两大通式来简单地总结：加密过程，c＝g^m*r^nmod n^2；解密过程，m＝L(c^lambda mod n^2)*u mod n；u＝(L(g^lambda mod n^2))^(-1)mod n；</td></tr><tr><td class="content" id="description_22">加法同态的验证过程。</td></tr><tr><td class="content" id="description_23">在上述的一种云计算中实现隐私保护的轻量级同态加密方法，密钥生成的具体过程是：</td></tr><tr><td class="content" id="description_24">步骤2.1、随机选取两个比较大的素数p和q，这两个数要同时满足两个条件：第一，p和q必须是非常大的素数，所谓素数也叫作质数，是在大于1的整数中，只能被1和这个数本身整除的数；第二、需要p和q这两个质数的长度相同，换言之，就是要求p和q满足gcd(p*q,(p-1)*(q-1))＝1；其中函数gcd()的作用就是返回两个整数的最大公约数，所以p和q满足p*q和(p-1)*(q-1)互为质数；</td></tr><tr><td class="content" id="description_25">步骤2.2、计算p*q，并且令n＝p*q，lambda＝lcm(p-1，q-1)；其中，函数lcm()是用来返回两个整数的最小公倍数，所以把p-1和q-1的最小公倍数赋值给lambda；</td></tr><tr><td class="content" id="description_26">步骤2.3、令nsquare＝n^2，上面介绍到Z<base:Sub>n</base:Sub>＝{x|x属于Z，0&amp;lt;＝x&amp;lt;＝n}，那么随机选取一个数g，使得g属于Z <base:Sub>n^2</base:Sub>，g是0到n^2中任意一个整数，但是g必要符合以下的条件：gcd{L(g^lambda mod n^2),n}＝1，其中mod是求余运算，A mod B表示A除以B的余数；</td></tr><tr><td class="content" id="description_27">步骤2.4、如果g满足这个条件，那么就可以令加密算法的公钥为(g，n)，私钥为lambda；如果g不满足以上条件，就输出“g is not good.Choose g again.”,继续在指定范围内选取g，直到满足条件，生成算法的公钥和私钥。</td></tr><tr><td class="content" id="description_28">3.根据权利要求1所述的一种云计算中实现隐私保护的轻量级同态加密方法，其特征在于，加密生成的具体过程是：</td></tr><tr><td class="content" id="description_29">首先输入一个正整数作为一个待加密的明文m，但是明文m是有范围的：0&amp;lt;m&amp;lt;n，即m是属于Z<base:Sub>n</base:Sub>；然后我们要随机选择一个整数r，r是一个随机整数明文，作用是来帮助加密明文m的，r属于Z<base:Sub>n</base:Sub><base:Sup>*</base:Sup>，即0&amp;lt;r&amp;lt;n；有了公钥(g，n)和随机明文r就能对明文m进行加密，令密文c是明文m加密狗对应的密文，于是就有：c＝g^m*r^n mod n^2，通过这个通式就能把明文加密成密文，完成加密算法。</td></tr><tr><td class="content" id="description_30">在上述的一种云计算中实现隐私保护的轻量级同态加密方法，解密的具体过程是：</td></tr><tr><td class="content" id="description_31">步骤4.1、，定义一个BigInteger u，使得u＝(L(g^lambda mod n^2))^(-1)modn.；</td></tr><tr><td class="content" id="description_32">步骤4.1、利用u进行对密文c的解密，利用通式——明文m＝L(c^lambda mod n^2)*u mod n；这部分算法的输入为密文c，返回的是明文m，其中L(x)是一个数学函数L(x)＝(x-1)/n。</td></tr><tr><td class="content" id="description_33">在上述的一种云计算中实现隐私保护的轻量级同态加密方法，密文的具体过程是：</td></tr><tr><td class="content" id="description_34">首先输入两个明文m1和m2，分别利用加密算法进行加密，得到两个密文em1和em2，使得他们两个密文相加，得到sum，然后利用解密算法给密文sum进行解密，然后比较解密后的明文和原来两个明文m1和m2的和有什么关系，如果两个相等，则此算法满足加法同态加密，否则，不满足。</td></tr><tr><td class="content" id="description_35">在上述的一种云计算中实现隐私保护的轻量级同态加密方法，在生成密钥后，就只要通过加密和解密算法就能加密明文和解密密文，在密钥的生成过程中有一个难点，那就是公钥(g，n)中g的产生；g的选择虽然是随意的，但是它是有条件限制的，g要满足两大条件：</td></tr><tr><td class="content" id="description_36">条件一，0&amp;lt;&amp;lt;g&amp;lt;n^2，其中&amp;lt;&amp;lt;表示远小于，表示g既要在0和n^2之间，还要远大于0；</td></tr><tr><td class="content" id="description_37">条件二，gcd{L(g^lambda mod n^2),n}＝1；如果直接这样找是很难找到满足条件的g的，所以我们可以利用逆向思维来思考问题；首先，我们令X1＝L(g^lambda mod n^2)，于是就有gcd(X1，n)＝1，就是说我们可以先找一个X1，使得X1和n互为质数，最小公约数为1，并且X1是小于n的；于是X1＝L(g^lambda mod n^2)＝(g^lambda mod n^2-1)/n，即化简可得：g^lambda mod n^2＝n*X1+1；由于X1小于n，所以n*X1+1小于n^2；此时可以令X2为g^lambda除以n^2的商，于是，g^lambda＝n^2*X2+n*X1+1；其中X2&amp;lt;n，通过这个算式推算出一个小于n^2的整数g。</td></tr><tr><td class="content" id="description_38">本发明的定位是对数据进行轻量级加密，保证其同态性，使得数据在不解密的情况下实现加法运算，而能保证结果不变。(1)从功能角度上：此算法是一个加密算法，所以自然而言地首先就是能实现对数据的加密功能。有加密，就有密钥，此算法在保证密钥长度尽量短的情况下，实现对明文的加密过程。然后就是此算法实现了同态加密算法的同态性，数据在不解密的前提下能被进行操作。(2)从应用角度上：该算法可以直接对加密的数据进行检索，不但能保证被检索的数据不被统计分析，还能对被检索的数据做基本的加法运算而不改变对应明文的顺序，既保护了用户的数据安全，又提高了检索效率。</td></tr><tr><td class="content" id="description_39">附图说明</td></tr><tr><td class="content" id="description_40">图1是对称加密体制原理图。</td></tr><tr><td class="content" id="description_41">图2是非对称加密体制原理图。</td></tr><tr><td class="content" id="description_42">图3是加法同态加密算法结构。</td></tr><tr><td class="content" id="description_43">具体实施方式</td></tr><tr><td class="content" id="description_44">本发明的算法功能主要包括：密钥的生成、数据的加密、数据的解密和密文的计算处理，总体结构如图3所示。其中，m为明文；e为密文；E为加密函数。</td></tr><tr><td class="content" id="description_45">输入输出设计：算法的输入是明文双正整数x和y，x和y都是属于正整数集Z<base:Sub>n</base:Sub>，其中Z<base:Sub>n</base:Sub>＝{x|x属于Z，0&amp;lt;＝x&amp;lt;＝n}。而算法的输出是密文，就算法的设计来看，此算法要生成公钥和私钥，然后通过密钥进行明文的加密和密文的解密，还有密文的计算，所以输出除了有密文外，还有计算结果。</td></tr><tr><td class="content" id="description_46">此算法的总原理跟公钥制加密密码体制一样，利用公开的公钥加密，用户利用自持私有的私钥解密。算法首先生成密钥，然后进行加密和解密过程。这两个过程可以分别用两大通式来简单地总结：加密过程，c＝g^m*r^n mod n^2；解密过程，m＝L(c^lambda mod n^2)*u mod n；u＝(L(g^lambda mod n^2))^(-1)mod n。最后就是加法同态的验证过程。</td></tr><tr><td class="content" id="description_47">各模块的详细思路如下:</td></tr><tr><td class="content" id="description_48">1、KeyGen算法(密钥生成)</td></tr><tr><td class="content" id="description_49">首先实现的就是算法的密钥生成，此算法的密钥分为私钥和公钥。不同于传统的对称加密机制，此算法的加密和解密使用的密钥有所不同，公钥：顾名思义就是一种公开的密钥，相对的私钥就是要保密的密钥。我们通过公钥和加密算法来给明文践行加密，而用户用自己私自持有的私钥来进行解密。虽然公钥是公开的，但是利用公钥和加密算法来推算出私钥是无法做到的，因为三者并没有确定的关系。所以这样就大大地增加了加密算法的安全性，只要接收方保护好自己持有的私钥，就能准确地为密文进行解密。</td></tr><tr><td class="content" id="description_50">KeyGen算法，也就是密钥生成算法，它的算法过程如下：</td></tr><tr><td class="content" id="description_51">(1)、随机选取两个比较大的素数p和q，这两个数要同时满足两个条件：第一，p和q必须是非常大的素数，所谓素数也叫作质数，是在大于1的整数中，只能被1和这个数本身整除的数。第二、需要p和q这两个质数的长度相同，换言之，就是要求p和q满足gcd(p*q,(p-1)*(q-1))＝1。其中函数gcd()的作用就是返回两个整数的最大公约数，所以p和q满足p*q和(p-1)*(q-1)互为质数。</td></tr><tr><td class="content" id="description_52">(2)、计算p*q，并且令n＝p*q，lambda＝lcm(p-1，q-1)。其中，函数lcm()是用来返回两个整数的最小公倍数，所以把p-1和q-1的最小公倍数赋值给lambda。</td></tr><tr><td class="content" id="description_53">(3)、令nsquare＝n^2，上面介绍到Z<base:Sub>n</base:Sub>＝{x|x属于Z，0&amp;lt;＝x&amp;lt;＝n}，那么随机选取一个数g，使得g属于Z <base:Sub>n^2</base:Sub>，g是0到n^2中任意一个整数，但是g必要符合以下的条件：gcd{L(g^lambda mod n^2),n}＝1，其中mod是求余运算，A mod B表示A除以B的余数。</td></tr><tr><td class="content" id="description_54">(4)、如果g满足这个条件，那么就可以令加密算法的公钥为(g，n)，私钥为lambda。如果g不满足以上条件，就输出“g is not good.Choose g again.”,继续在指定范围内选取g，直到满足条件，生成算法的公钥和私钥。</td></tr><tr><td class="content" id="description_55">2、Enc算法(加密算法)</td></tr><tr><td class="content" id="description_56">上面介绍了密钥中公钥和私钥的生成算法，有了公钥，我们知道就可以进行加密算法。从第二章知道在公钥制度中，公钥是公开的，并且加密算法中的加密操作就是利用公钥和加密函数来进行的。</td></tr><tr><td class="content" id="description_57">加密算法过程其实很简单，就是首先输入一个正整数作为一个待加密的明文m，但是明文m是有范围的：0&amp;lt;m&amp;lt;n，即m是属于Z<base:Sub>n</base:Sub>。然后我们要随机选择一个整数r，r是一个随机整数明文，作用是来帮助加密明文m的，r属于Z<base:Sub>n</base:Sub><base:Sup>*</base:Sup>，即0&amp;lt;r&amp;lt;n。有了公钥(g，n)和随机明文r就能对明文m进行加密，令密文c是明文m加密狗对应的密文，于是就有：c＝g^m*r^n mod n^2，通过这个通式就能把明文加密成密文，完成加密算法。</td></tr><tr><td class="content" id="description_58">为了实现这个加密通式，要用到一个Java语句中的一个特殊的函数modPow()。算法BigInteger s.modPow(BigInteger exponent,BigInteger m)将会返回一个BigInteger，其中BigInteger exponent表示指数，BigInteger m表示模，并且返回的BigInteger值为：s<base:Sup>exponent</base:Sup> mod m。举个简单的例子：7.modPow(2,20)的运算过程为：7^2＝49，然后mod 20，所以结果为：9。</td></tr><tr><td class="content" id="description_59">3、Dec算法(解密算法)</td></tr><tr><td class="content" id="description_60">设计完加密算法Enc，下面自然是解密算法Dec，上面我们提到，解密算法是利用用户持有的私钥和解密算法来给密文解密的。从上面的密钥生成算法KeyGen可以知道：算法的私钥为：lambda。</td></tr><tr><td class="content" id="description_61">解密算法分为两步：第一步，定义一个BigInteger u，使得u＝(L(g^lambda mod n^2))^(-1)mod n.；第二步，利用u进行对密文c的解密，利用通式——明文m＝L(c^lambdamod n^2)*u mod n。这部分算法的输入为密文c，返回的是明文m，其中L(x)是一个数学函数L(x)＝(x-1)/n。</td></tr><tr><td class="content" id="description_62">从上面的加密算法和解密算法送使用的密钥可以看出：解密过程需要用到私钥和公钥，而加密过程只用到了公钥，然而公钥是公开的，并且私钥lambda是无法从公钥(g，n)中推导出来的，所以只要用户端能够保护好自己持有的私钥，别人就无法知道密文的内容，密文自然就是安全的。</td></tr><tr><td class="content" id="description_63">4、Evaluate算法(密文计算算法)</td></tr><tr><td class="content" id="description_64">这部分算法就是用来验证同态加密算法的同态性的。设计算法时说过，此算法是加法同态加密算法，于是需要验证它的加法同态性。如何验证加法同态呢？我们现在就以最简单两个明文来说明一下：我们首先输入两个明文m1和m2，分别利用上面的加密算法进行加密，得到两个密文em1和em2，使得他们两个密文相加，得到sum，然后利用上面的解密算法给密文sum进行解密，然后比较解密后的明文和原来两个明文m1和m2的和有什么关系，如果两个相等，则此算法满足加法同态加密，否则，不满足。</td></tr><tr><td class="content" id="description_65">此算法在生成密钥后，就只要通过加密和解密算法就能加密明文和解密密文，比较简单，但是在密钥的生成过程中有一个难点，那就是公钥(g，n)中g的产生。上面的介绍我们知道，g的选择虽然是随意的，但是它是有条件限制的，g要满足两大条件：</td></tr><tr><td class="content" id="description_66">第一，0&amp;lt;&amp;lt;g&amp;lt;n^2，其中&amp;lt;&amp;lt;表示远小于，表示g既要在0和n^2之间，还要远大于0。</td></tr><tr><td class="content" id="description_67">第二，gcd{L(g^lambda mod n^2),n}＝1。如果直接这样找是很难找到满足条件的g的，所以我们可以利用逆向思维来思考问题。首先，我们令X1＝L(g^lambda mod n^2)，于是就有gcd(X1，n)＝1，就是说我们可以先找一个X1，使得X1和n互为质数，最小公约数为1，并且X1是小于n的。于是X1＝L(g^lambda mod n^2)＝(g^lambda mod n^2-1)/n，即化简可得：g^lambda mod n^2＝n*X1+1。由于X1小于n，所以n*X1+1小于n^2。此时可以令X2为g^lambda除以n^2的商，于是，g^lambda＝n^2*X2+n*X1+1。其中X2&amp;lt;n，通过这个算式我们推算出一个小于n^2的整数g就没有之前那么难了。</td></tr><tr><td class="content" id="description_68">本文中所描述的具体实施例仅仅是对本发明精神作举例说明。本发明所属技术领域的技术人员可以对所描述的具体实施例做各种各样的修改或补充或采用类似的方式替代，但并不会偏离本发明的精神或者超越所附权利要求书所定义的范围。</td></tr></table></div></body></html>